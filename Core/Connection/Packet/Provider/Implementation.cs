using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Xintric.DataRouter.Core.Connection.Packet.Provider
{
    public class Implementation : IProvider
    {
        [Flags]
        public enum AutoGenerateFlags
        {
            ScanCurrentAssembly = 1,
            ScanEntireDomain = 2,
            IncludePreregisteredFactories = 4,
        }

        public Implementation(AutoGenerateFlags generateflags = AutoGenerateFlags.ScanCurrentAssembly | AutoGenerateFlags.IncludePreregisteredFactories)
        {
            if (generateflags.HasFlag(AutoGenerateFlags.ScanCurrentAssembly))
            {
                foreach (var factory in GenerateFactories(Assembly.GetExecutingAssembly())) RegisterFactory(factory);
            }
            if (generateflags.HasFlag(AutoGenerateFlags.ScanEntireDomain))
            {
                foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
                {
                    foreach (var factory in GenerateFactories(asm)) RegisterFactory(factory);
                }
            }
            if (generateflags.HasFlag(AutoGenerateFlags.IncludePreregisteredFactories))
            {
                foreach (var f in preregisteredfactories) RegisterFactory(f);
            }
        }

        public string GetNameOf(IPacket packet)
        {
            try
            {
                return Factories.First(x => x.IsMine(packet)).Name;
            }
            catch (Exception e)
            {
                throw e;
            }
        }


        Dictionary<string, IFactory> factories = new Dictionary<string, IFactory>();
        public IEnumerable<IFactory> Factories
        {
            get
            {
                return factories.Select(x => x.Value);
            }
        }

        public void RegisterFactory(IFactory factory)
        {
            factories[factory.Name] = factory;
        }

        static HashSet<IFactory> preregisteredfactories = new HashSet<IFactory>();
        public static void PreregisterFactory(IFactory factory)
        {
            preregisteredfactories.Add(factory);
        }

        public IPacket Create(string type, byte[] data)
        {
            return factories[type].Create(data);
        }

        public static IEnumerable<IFactory> GenerateFactories(Assembly asm)
        {
 
            foreach (var type in asm.GetTypes().Where(x =>
            x.GetInterfaces().Contains(typeof(Xintric.DataRouter.Core.Connection.IPacket))
            && !x.IsInterface
            && !x.IsAbstract
            && x.GetCustomAttributes(typeof(Xintric.DataRouter.Core.Connection.Packet.AutoGenerateFactoryAttribute), true).Length > 0
            ))
            {

                yield return GenerateFactory(type); 

            }
        }


        public static IFactory GenerateFactory(Type type)
        {
            if (autogeneratedfactories.ContainsKey(type)) return autogeneratedfactories[type];
            var method = type.GetMethod("FromByteArray");
            if (method == null) throw new MissingMethodException("public static IPacket " + type.FullName, "FromByteArray");
            if ((method.Attributes & MethodAttributes.Static) != MethodAttributes.Static) throw new MissingMethodException("The method FromByteArray must be declared static.");

            var ret = new AutoGeneratedFactory(type, data =>
            {
                return (Xintric.DataRouter.Core.Connection.IPacket)method.Invoke(null, new object[] { data });
            });
            autogeneratedfactories[type] = ret;
            return ret;
        }
        static Dictionary<Type, AutoGeneratedFactory> autogeneratedfactories = new Dictionary<Type, AutoGeneratedFactory>();


        class AutoGeneratedFactory : IFactory
        {
            public AutoGeneratedFactory(Type type, Func<byte[], IPacket> func)
            {
                PacketType = type;
                FromByteArray = func;
            }
            public Func<byte[], IPacket> FromByteArray { get; private set; }

            public Type PacketType { get; private set; }
            public string Name { get { return PacketType.FullName; } }

            public IPacket Create(byte[] data)
            {
                return FromByteArray(data);
            }

            public bool IsMine(IPacket packet)
            {
                return packet.GetType() == PacketType;
            }
        }


    }
}
